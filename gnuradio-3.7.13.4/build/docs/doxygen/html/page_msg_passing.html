<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GNU Radio Manual and C++ API Reference: Message Passing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gnuradio_logo_icon.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio Manual and C++ API Reference
   &#160;<span id="projectnumber">3.7.13.4</span>
   </div>
   <div id="projectbrief">The Free &amp; Open Software Radio Ecosystem</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_msg_passing.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Message Passing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="msg_passing_introduction"></a>
Introduction</h1>
<p>GNU Radio was originally a streaming system with no other mechanism to pass data between blocks. Streams of data are a model that work well for samples, bits, etc., but are not really the right mechanism for control data, metadata, or packet structures (at least at some point in the processing chain).</p>
<p>We solved part of this problem by introducing the tag stream (see <a class="el" href="page_stream_tags.html">Stream Tags</a>). This is a parallel stream to the data streaming. The difference is that tags are designed to hold metadata and control information. Tags are specifically associated with a particular sample in the data stream and flow downstream alongside the data. This model allows other blocks to identify that an event or action has occurred or should occur on a particular item. The major limitation is that the tag stream is really only accessible inside a work function and only flows in one direction. Its benefit is that it is isosynchronous with the data.</p>
<p>We want a more general message passing system for a couple of reasons. The first is to allow blocks downstream to communicate back to blocks upstream. The second is to allow an easier way for us to communicate back and forth between external applications and GNU Radio. GNU Radio's message passing interface handles these cases, although it does so on an asynchronous basis.</p>
<p>The message passing interface heavily relies on Polymorphic Types (PMTs) in GNU Radio. For further information about these data structures, see the page <a class="el" href="page_pmt.html">Polymorphic Types</a>.</p>
<h1><a class="anchor" id="msg_passing_api"></a>
Message Passing API</h1>
<p>The message passing interface is designed into the <a class="el" href="classgr_1_1basic__block.html" title="The abstract base class for all signal processing blocks.Basic blocks are the bare abstraction of an ...">gr::basic_block</a>, which is the parent class for all blocks in GNU Radio. Each block has a set of message queues to hold incoming messages and can post messages to the message queues of other blocks. The blocks also distinguish between input and output ports.</p>
<p>A block has to declare its input and output message ports in its constructor. The message ports are described by a name, which is in practice a PMT symbol (<em>i.e.</em>, an interned string). The API calls to register a new port are:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> message_port_register_in(<a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> port_id)</div>
<div class="line"><span class="keywordtype">void</span> message_port_register_out(<a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> port_id)</div>
</div><!-- fragment --><p>In Python:</p>
<div class="fragment"><div class="line"><span class="keyword">self</span>.message_port_register_in(pmt.intern(<span class="stringliteral">&quot;port name&quot;</span>))</div>
<div class="line"><span class="keyword">self</span>.message_port_register_out(pmt.intern(<span class="stringliteral">&quot;port name&quot;</span>))</div>
</div><!-- fragment --><p>The ports are now identifiable by that port name. Other blocks who may want to post or receive messages on a port must subscribe to it. When a block has a message to send, they are published on a particular port using the following API:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> message_port_pub(<a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> port_id, <a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> msg);</div>
</div><!-- fragment --><p>In Python:</p>
<div class="fragment"><div class="line"><span class="keyword">self</span>.message_port_pub(pmt.intern(<span class="stringliteral">&quot;port name&quot;</span>), &lt;pmt message&gt;)</div>
</div><!-- fragment --><p>Subscribing is usually done in the form of connecting message ports as part of the flowgraph, as discussed later. Internally, when message ports are connected, the <a class="el" href="classgr_1_1basic__block.html#adddd339f229f55bd96229d7a7dd5cc8f">gr::basic_block::message_port_sub</a> method is called.</p>
<p>Any block that has a subscription to another block's output message port will receive the message when it is published. Internally, when a block publishes a message, it simply iterates through all blocks that have subscribed and uses the <a class="el" href="classgr_1_1basic__block.html#ab82376fe13f515cb904c0d2e9fec87b6">gr::basic_block::_post</a> method to send the message to that block's message queue.</p>
<h2><a class="anchor" id="msg_passing_msg_handler"></a>
Message Handler Functions</h2>
<p>A subscriber block must declare a message handler function to process the messages that are posted to it. After using the <a class="el" href="classgr_1_1basic__block.html#a362b6de38292cca9c1d56439a6efad04">gr::basic_block::message_port_register_in</a> to declare a subscriber port, we must then bind this port to the message handler. For this, we use Boost's 'bind' function:</p>
<div class="fragment"><div class="line">set_msg_handler(<a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> port_id,</div>
<div class="line">  boost::bind(&amp;block_class::message_handler_function, <span class="keyword">this</span>, _1));</div>
</div><!-- fragment --><p>In Python:</p>
<div class="fragment"><div class="line"><span class="keyword">self</span>.set_msg_handler(pmt.intern(<span class="stringliteral">&quot;port name&quot;</span>), &lt;msg handler <span class="keyword">function</span>&gt;)</div>
</div><!-- fragment --><p>When a new message is pushed onto a port's message queue, it is this function that is used to process the message. The 'port_id' is the same PMT as used when registering the input port. The 'block_class::message_handler_function' is the member function of the class designated to handle messages to this port. The 'this' and '_1' are standard ways of using the Boost bind function to pass the 'this' pointer as the first argument to the class (standard OOP practice) and the _1 is an indicator that the function expects 1 additional argument. The prototype for all message handling functions is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> block_class::message_handler_function(<a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> msg);</div>
</div><!-- fragment --><p>In Python the equivalent function would be:</p>
<div class="fragment"><div class="line">def handle_msg(<span class="keyword">self</span>, msg):</div>
</div><!-- fragment --><p>We give examples of using this below.</p>
<h2><a class="anchor" id="msg_passing_fg_connect"></a>
Connecting Messages through the Flowgraph</h2>
<p>From the flowgraph level, we have instrumented a <a class="el" href="classgr_1_1hier__block2.html#a8abff96c559930893d3ffdb22a3c43fd" title="Add gr-blocks or hierarchical blocks to internal graph and wire together. ">gr::hier_block2::msg_connect</a> method to make it easy to subscribe blocks to other blocks' messages. Assume that the block <b>src</b> has an output message port named <em>pdus</em> and the block <b>dbg</b> has an input port named <em>print</em>. The message connection in the flowgraph (in Python) looks like the following:</p>
<div class="fragment"><div class="line"><span class="keyword">self</span>.tb.msg_connect(src, <span class="stringliteral">&quot;pdus&quot;</span>, dbg, <span class="stringliteral">&quot;print&quot;</span>)</div>
</div><!-- fragment --><p>All messages published by the <b>src</b> block on port <em>pdus</em> will be received by <b>dbg</b> on port <em>print</em>. Note here how we are just using strings to define the ports, not PMT symbols. This is a convenience to the user to be able to more easily type in the port names (for reference, you can create a PMT symbol in Python using the <a class="el" href="namespacepmt.html#a2a19d2e56f6fbb5645ad17a5937b5f2f" title="Alias for pmt_string_to_symbol. ">pmt::intern</a> function as <a class="el" href="namespacepmt.html#a2a19d2e56f6fbb5645ad17a5937b5f2f" title="Alias for pmt_string_to_symbol. ">pmt.intern</a>("string")).</p>
<p>Users can also query blocks for the names of their input and output ports using the following API calls:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> message_ports_in();</div>
<div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> message_ports_out();</div>
</div><!-- fragment --><p>The return value for these are a PMT vector filled with PMT symbols, so PMT operators must be used to manipulate them.</p>
<p>Each block has internal methods to handle posting and receiving of messages. The <a class="el" href="classgr_1_1basic__block.html#ab82376fe13f515cb904c0d2e9fec87b6">gr::basic_block::_post</a> method takes in a message and places it into its queue. The publishing model uses the <a class="el" href="classgr_1_1basic__block.html#ab82376fe13f515cb904c0d2e9fec87b6">gr::basic_block::_post</a> method of the blocks as the way to access the message queue. So the message queue of the right name will have a new message. Posting messages also has the benefit of waking up the block's thread if it is in a wait state. So if idle, as soon as a message is posted, it will wake up and call the message handler.</p>
<h1><a class="anchor" id="msg_passing_posting"></a>
Posting from External Sources</h1>
<p>An important feature of the message passing architecture is how it can be used to take in messages from an external source. We can call a block's <a class="el" href="classgr_1_1basic__block.html#ab82376fe13f515cb904c0d2e9fec87b6">gr::basic_block::_post</a> method directly and pass it a message. So any block with an input message port can receive messages from the outside in this way.</p>
<p>The following example uses a <a class="el" href="classgr_1_1blocks_1_1pdu__to__tagged__stream.html" title="Turns received PDUs into a tagged stream of items. ">gr::blocks::pdu_to_tagged_stream</a> block as the source block to a flowgraph. Its purpose is to wait for messages as PDUs posted to it and convert them to a normal stream. The payload will be sent on as a normal stream while the meta data will be decoded into tags and sent on the tagged stream.</p>
<p>So if we have created a <b>src</b> block as a PDU to stream, it has a <em>pdus</em> input port, which is how we will inject PDU messages into the flowgraph. These PDUs could come from another block or flowgraph, but here, we will create and insert them by hand.</p>
<div class="fragment"><div class="line">port = pmt.intern(<span class="stringliteral">&quot;pdus&quot;</span>)</div>
<div class="line">msg = pmt.cons(pmt.PMT_NIL, pmt.make_u8vector(16, 0xFF))</div>
<div class="line">src.to_basic_block()._post(port, msg)</div>
</div><!-- fragment --><p>The PDU's metadata section is empty, hence the pmt::PMT_NIL object. The payload is now just a simple vector of 16 bytes of all 1's. To post the message, we have to access the block's <a class="el" href="classgr_1_1basic__block.html" title="The abstract base class for all signal processing blocks.Basic blocks are the bare abstraction of an ...">gr::basic_block</a> class, which we do using the <a class="el" href="classgr_1_1basic__block.html#a84bf6924dfa0bb724caca46575669557">gr::basic_block::to_basic_block</a> method and then call the <a class="el" href="classgr_1_1basic__block.html#ab82376fe13f515cb904c0d2e9fec87b6">gr::basic_block::_post</a> method to pass the PDU to the right port.</p>
<p>All of these mechanisms are explored and tested in the QA code of the file qa_pdu.py.</p>
<p>There are some examples of using the message passing infrastructure through GRC in gr-blocks/examples/msg_passing.</p>
<h1><a class="anchor" id="msg_passing_commands"></a>
Using messages as commands</h1>
<p>One important use of messages is to send commands to blocks. Examples for this include:</p>
<ul>
<li><a class="el" href="classgr_1_1qtgui_1_1freq__sink__c.html" title="A graphical sink to display multiple signals in frequency. ">gr::qtgui::freq_sink_c</a>: The scaling of the frequency axis can be changed by messages</li>
<li><a class="el" href="classgr_1_1uhd_1_1usrp__source.html">gr::uhd::usrp_source</a> and <a class="el" href="classgr_1_1uhd_1_1usrp__sink.html">gr::uhd::usrp_sink</a>: Many transceiver-related settings can be manipulated through command messages, such as frequency, gain and LO offset</li>
<li><a class="el" href="classgr_1_1digital_1_1header__payload__demux.html" title="Header/Payload demuxer (HPD). ">gr::digital::header_payload_demux</a>, which receives an acknowledgement from a header parser block on how many payload items there are to process</li>
</ul>
<p>There is no special PMT type to encode commands, however, it is strongly recommended to use one of the following formats:</p>
<ul>
<li>pmt::cons(KEY, VALUE): This format is useful for commands that take a single value. Think of KEY and VALUE as the argument name and value, respectively. For the case of the QT GUI Frequency Sink, KEY would be "freq" and VALUE would be the new center frequency in Hz.</li>
<li>pmt::dict((KEY1: VALUE1), (KEY2: VALUE2), ...): This is basically the same as the previous format, but you can provide multiple key/value pairs. This is particularly useful when a single command takes multiple arguments which can't be broken into multiple command messages (e.g., the USRP blocks might have both a timestamp and a center frequency in a command message, which are closely associated).</li>
</ul>
<p>In both cases, all KEYs should be pmt::symbols (i.e. strings). VALUEs can be whatever the block requires.</p>
<p>It might be tempting to deviate from this format, e.g. the QT Frequency sink could simply take a float value as a command message, and it would still work fine. However, there are some very good reasons to stick to this format:</p>
<ul>
<li>Interoperability: The more people use the standard format, the more likely it is that blocks from different sources can work together</li>
<li>Inspectability: A message debug block will display more useful information about a message if it's containing both a value and a key</li>
<li>Intuition: This format is pretty versatile and unlikely to create situations where it is not sufficient (especially considering that values are PMTs themselves). As a counterexample, using positional arguments (something like "the first argument
  is the frequency, the second the gain") is easily forgotten, or changed in one place and not another, etc.</li>
</ul>
<h1><a class="anchor" id="msg_passing_examples"></a>
Code Examples</h1>
<p>The following is snippets of code from blocks currently in GNU Radio that take advantage of message passing. We will be using <a class="el" href="classgr_1_1blocks_1_1message__debug.html" title="Debug block for the message passing system. ">gr::blocks::message_debug</a> and <a class="el" href="classgr_1_1blocks_1_1tagged__stream__to__pdu.html" title="Turns received stream data and tags into PDUs and sends them through a message port.The sent message is a PMT-pair (created by pmt::cons()). The first element is a dictionary containing all the tags. The second is a vector containing the actual data. ">gr::blocks::tagged_stream_to_pdu</a> below to show setting up both input and output message passing capabilities.</p>
<p>The <a class="el" href="classgr_1_1blocks_1_1message__debug.html" title="Debug block for the message passing system. ">gr::blocks::message_debug</a> block is used for debugging the message passing system. It describes three input message ports: <em>print</em>, <em>store</em>, and <em>pdu_print</em>. The <em>print</em> port simply prints out all messages to standard out while the <em>store</em> port keeps a list of all messages posted to it. The <em>pdu_print</em> port specially formats PDU messages for printing to standard out. The <em>store</em> port works in conjunction with a <a class="el" href="classgr_1_1blocks_1_1message__debug.html#ad3cc1e2fa2412307b3cb5b33c14f0c8b" title="Get a message (as a PMT) from the message vector at index i. ">gr::blocks::message_debug::get_message(int i)</a> call that allows us to retrieve message <code>i</code> afterward.</p>
<p>The constructor of this block looks like this:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  message_port_register_in(<a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(<span class="stringliteral">&quot;print&quot;</span>));</div>
<div class="line">  set_msg_handler(<a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(<span class="stringliteral">&quot;print&quot;</span>),</div>
<div class="line">    boost::bind(&amp;<a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">message_debug_impl::print</a>, <span class="keyword">this</span>, _1));</div>
<div class="line"></div>
<div class="line">  message_port_register_in(<a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(<span class="stringliteral">&quot;store&quot;</span>));</div>
<div class="line">  set_msg_handler(<a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(<span class="stringliteral">&quot;store&quot;</span>),</div>
<div class="line">    boost::bind(&amp;message_debug_impl::store, <span class="keyword">this</span>, _1));</div>
<div class="line"></div>
<div class="line">  message_port_register_in(<a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(<span class="stringliteral">&quot;print_pdu&quot;</span>));</div>
<div class="line">  set_msg_handler(<a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(<span class="stringliteral">&quot;print_pdu&quot;</span>),</div>
<div class="line">    boost::bind(&amp;message_debug_impl::print_pdu, <span class="keyword">this</span>, _1));</div>
<div class="line">}</div>
</div><!-- fragment --><p>The three message input ports are registered by their respective names. We then use the <a class="el" href="classgr_1_1basic__block.html#a7fed11ec01538bfea999fb37687b43b4" title="Set the callback that is fired when messages are available. ">gr::basic_block::set_msg_handler</a> function to identify this particular port name with a callback function. The Boost <em>bind</em> function (<a href="http://www.boost.org/doc/libs/1_52_0/libs/bind/bind.html" target="_blank">Boost::bind</a>) here binds the callback to a function of this block's class. So now the functions in the block's private implementation class, gr::blocks::message_debug_impl::print, gr::blocks::message_debug_impl::store, and gr::blocks::message_debug_impl::print_pdu, are assigned to handle messages passed to them. Below is the <em>print</em> function for reference.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">message_debug_impl::print</a>(<a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> msg)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;***** MESSAGE DEBUG PRINT ********\n&quot;</span>;</div>
<div class="line">  <a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">pmt::print</a>(msg);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;**********************************\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The function simply takes in the PMT message and prints it. The method <a class="el" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886" title="Write pmt string representation to stdout. ">pmt::print</a> is a function in the PMT library to print the PMT in a friendly and (mostly) pretty manner.</p>
<p>The <a class="el" href="classgr_1_1blocks_1_1tagged__stream__to__pdu.html" title="Turns received stream data and tags into PDUs and sends them through a message port.The sent message is a PMT-pair (created by pmt::cons()). The first element is a dictionary containing all the tags. The second is a vector containing the actual data. ">gr::blocks::tagged_stream_to_pdu</a> block only defines a single output message port. In this case, its constructor contains the line:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  message_port_register_out(<a class="code" href="namespacegr_1_1blocks_1_1pdu.html#a8b1b82ac4dfe1bf302d850a62c862a07">pdu_port_id</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>So we are only creating a single output port where <em>pdu_port_id</em> is defined in the file <a class="el" href="pdu_8h.html">pdu.h</a> as <em>pdus</em>.</p>
<p>This block's purpose is to take in a stream of samples along with stream tags and construct a predefined PDU message from it. In GNU Radio, we define a PDU as a PMT pair of (metadata, data). The metadata describes the samples found in the data portion of the pair. Specifically, the metadata can contain the length of the data segment and any other information (sample rate, etc.). The PMT vectors know their own length, so the length value is not actually necessary unless useful for purposes down the line. The metadata is a PMT dictionary while the data segment is a PMT uniform vector of either bytes, floats, or complex values.</p>
<p>In the end, when a PDU message is ready, the block calls its gr::blocks::tagged_stream_to_pdu_impl::send_message function that is shown below.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">tagged_stream_to_pdu_impl::send_message()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code" href="namespacepmt.html#a8b181f253f877ade7bb7bf37d0b64627">pmt::length</a>(d_pdu_vector) != d_pdu_length) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;msg length not correct&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> msg = <a class="code" href="namespacepmt.html#a7ab95721db5cbda1852f13a92eee5362">pmt::cons</a>(d_pdu_meta,</div>
<div class="line">                             d_pdu_vector);</div>
<div class="line">  message_port_pub(<a class="code" href="namespacegr_1_1blocks_1_1pdu.html#a8b1b82ac4dfe1bf302d850a62c862a07">pdu_port_id</a>, msg);</div>
<div class="line"></div>
<div class="line">  d_pdu_meta = <a class="code" href="pmt_8h.html#aa83efad7d7f377e5c9e06279a93221da">pmt::PMT_NIL</a>;</div>
<div class="line">  d_pdu_vector = <a class="code" href="pmt_8h.html#aa83efad7d7f377e5c9e06279a93221da">pmt::PMT_NIL</a>;</div>
<div class="line">  d_pdu_length = 0;</div>
<div class="line">  d_pdu_remain = 0;</div>
<div class="line">  d_inpdu = <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function does a bit of checking to make sure the PDU is OK as well as some cleanup in the end. But it is the line where the message is published that is important to this discussion. Here, the block posts the PDU message to any subscribers by calling <a class="el" href="classgr_1_1basic__block.html#a485fa8f9fa04a1abcfe3f111d22e8e5f">gr::basic_block::message_port_pub</a> publishing method.</p>
<p>There is similarly a <a class="el" href="classgr_1_1blocks_1_1pdu__to__tagged__stream.html" title="Turns received PDUs into a tagged stream of items. ">gr::blocks::pdu_to_tagged_stream</a> block that essentially does the opposite. It acts as a source to a flowgraph and waits for PDU messages to be posted to it on its input port <em>pdus</em>. It extracts the metadata and data and processes them. The metadata dictionary is split up into key:value pairs and stream tags are created out of them. The data is then converted into an output stream of items and passed along. The next section describes how PDUs can be passed into a flowgraph using the <a class="el" href="classgr_1_1blocks_1_1pdu__to__tagged__stream.html" title="Turns received PDUs into a tagged stream of items. ">gr::blocks::pdu_to_tagged_stream</a> block.</p>
<p>For a Python block example, see <a class="el" href="page_python_blocks.html#pyblocks_msgs">Using Message Passing</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
