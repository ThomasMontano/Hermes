<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GNU Radio Manual and C++ API Reference: Tagged Stream Blocks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gnuradio_logo_icon.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio Manual and C++ API Reference
   &#160;<span id="projectnumber">3.7.13.4</span>
   </div>
   <div id="projectbrief">The Free &amp; Open Software Radio Ecosystem</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_tagged_stream_blocks.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tagged Stream Blocks </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="tsb_introduction"></a>
Introduction</h1>
<p>A tagged stream block is a block that works on streamed, but packetized input data. Think of packet data transmission: A data packet consists of N bytes. However, in traditional GNU Radio blocks, if we stream N bytes into a block, there's no way of knowing the packet boundary. This might be relevant: Perhaps the modulator has to prepend a synchronisation word before every packet, or append a CRC. So while some blocks don't care about packet boundaries, other blocks do: These are <em>tagged stream blocks</em>.</p>
<p>These blocks are different from all the other GNU Radio block types (<a class="el" href="classgr_1_1block.html" title="The abstract base class for all &#39;terminal&#39; processing blocks.A signal processing flow is constructed ...">gr::block</a>, <a class="el" href="classgr_1_1sync__block.html" title="synchronous 1:1 input to output with historyOverride work to provide the signal processing implementa...">gr::sync_block</a> etc.) in that they are driven by the input: The PDU length tag tells the block how to operate, whereas other blocks are output-driven (the scheduler tries to fill up the output buffer are much as possible).</p>
<h2><a class="anchor" id="tsb_howtheywork"></a>
How do they work?</h2>
<p>As the name implies, tagged stream blocks use tags to identify PDU boundaries. On the first item of a streamed PDU, there <em>must</em> be a tag with a specific key, which stores the length of the PDU as a PMT integer. If anything else, or no tag, is on this first item, this will cause the flow graph to crash!</p>
<p>The scheduler then takes care of everything. When the work function is called, it is guaranteed to contain exactly one complete PDU and enough space in the output buffer for the output.</p>
<h2><a class="anchor" id="tsb_relatestootherblocks"></a>
How do they relate to other block types (e.g. sync blocks)?</h2>
<p>Tagged stream blocks and sync blocks are really orthogonal concepts, and a block could be both (<a class="el" href="classgr_1_1digital_1_1ofdm__frame__equalizer__vcvc.html" title="OFDM frame equalizer. ">gr::digital::ofdm_frame_equalizer_vcvc</a> is such a block). However, because the work function is defined differently in these block types, there is no way to derive a block from both <a class="el" href="classgr_1_1tagged__stream__block.html" title="Block that operates on PDUs in form of tagged streamsOverride work to provide the signal processing i...">gr::tagged_stream_block</a> and <a class="el" href="classgr_1_1sync__block.html" title="synchronous 1:1 input to output with historyOverride work to provide the signal processing implementa...">gr::sync_block</a>.</p>
<p>If a block needs the tagged stream mechanism (i.e. knowing about PDU boundaries), it must be derived from <a class="el" href="classgr_1_1tagged__stream__block.html" title="Block that operates on PDUs in form of tagged streamsOverride work to provide the signal processing i...">gr::tagged_stream_block</a>. If it's also a sync block, it is still possible to set <a class="el" href="classgr_1_1block.html#aff3003eea3517dd3e8d9a5297c1196b1" title="Set the approximate output rate / input rate. ">gr::block::set_relative_rate</a>(1.0) and/or the fixed rate functions.</p>
<p>The way <a class="el" href="classgr_1_1tagged__stream__block.html" title="Block that operates on PDUs in form of tagged streamsOverride work to provide the signal processing i...">gr::tagged_stream_block</a> works, it is still beneficial to specify a relative rate, if possible.</p>
<h1><a class="anchor" id="tsb_creating"></a>
Creating a tagged stream block</h1>
<p>To create a tagged stream block, the block must be derived from <a class="el" href="classgr_1_1tagged__stream__block.html" title="Block that operates on PDUs in form of tagged streamsOverride work to provide the signal processing i...">gr::tagged_stream_block</a>. Here's a minimal example of how the header file could look: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gr-digital_2include_2gnuradio_2digital_2api_8h.html">gnuradio/digital/api.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tagged__stream__block_8h.html">gnuradio/tagged_stream_block.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>gr {</div>
<div class="line">  <span class="keyword">namespace </span>digital {</div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span><a class="code" href="gr-digital_2include_2gnuradio_2digital_2api_8h.html#ae14969f36ec69051c4b2f13a0db7e9ba">DIGITAL_API</a> crc32_bb : <span class="keyword">virtual</span> <span class="keyword">public</span> tagged_stream_block</div>
<div class="line">    {</div>
<div class="line">     <span class="keyword">public</span>:</div>
<div class="line">      <span class="keyword">typedef</span> boost::shared_ptr&lt;crc32_bb&gt; sptr;</div>
<div class="line"></div>
<div class="line">      <span class="keyword">static</span> sptr make(<span class="keywordtype">bool</span> check=<span class="keyword">false</span>, <span class="keyword">const</span> std::string&amp; len_tag_key=<span class="stringliteral">&quot;packet_len&quot;</span>);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">  } <span class="comment">// namespace digital</span></div>
<div class="line">} <span class="comment">// namespace gr</span></div>
</div><!-- fragment --><p>It is very similar to any other block definition. Two things are stand out: First, <a class="el" href="tagged__stream__block_8h.html">gnuradio/tagged_stream_block.h</a> is included to allow deriving from <a class="el" href="classgr_1_1tagged__stream__block.html" title="Block that operates on PDUs in form of tagged streamsOverride work to provide the signal processing i...">gr::tagged_stream_block</a>.</p>
<p>The other thing is in the make function: the second argument is a string containing the key of the length tags. This is not necessary (the block could get this information hard-coded), but the usual way is to allow the user to change this tag, but give a default value (in this case, <code>packet_len</code>).</p>
<p>The implementation header (*_impl.h) also looks a bit different (again this is cropped to the relevant parts): </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="crc32__bb_8h.html">digital/crc32_bb.h</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>gr {</div>
<div class="line">  <span class="keyword">namespace </span>digital {</div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>crc32_bb_impl : <span class="keyword">public</span> crc32_bb</div>
<div class="line">    {</div>
<div class="line">     <span class="keyword">public</span>:</div>
<div class="line">      crc32_bb_impl(<span class="keywordtype">bool</span> check, <span class="keyword">const</span> std::string&amp; len_tag_key);</div>
<div class="line">      ~crc32_bb_impl();</div>
<div class="line"></div>
<div class="line">      <span class="keywordtype">int</span> calculate_output_stream_length(<span class="keyword">const</span> <a class="code" href="gnuradio-runtime_2include_2gnuradio_2types_8h.html#ab02d0a829d67d39e3ac3163016d3a8be">gr_vector_int</a> &amp;ninput_items);</div>
<div class="line">      <span class="keywordtype">int</span> work(<span class="keywordtype">int</span> noutput_items,</div>
<div class="line">                       <a class="code" href="gnuradio-runtime_2include_2gnuradio_2types_8h.html#ab02d0a829d67d39e3ac3163016d3a8be">gr_vector_int</a> &amp;ninput_items,</div>
<div class="line">                       <a class="code" href="gnuradio-runtime_2include_2gnuradio_2types_8h.html#a9852a3d906d823cb70eb9c29e7f2a43d">gr_vector_const_void_star</a> &amp;input_items,</div>
<div class="line">                       <a class="code" href="gnuradio-runtime_2include_2gnuradio_2types_8h.html#acd3f499576e769966ea44554b359d949">gr_vector_void_star</a> &amp;output_items);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">  } <span class="comment">// namespace digital</span></div>
<div class="line">} <span class="comment">// namespace gr</span></div>
</div><!-- fragment --><p>First, the <code>work</code> function signature is new. The argument list looks like that from <a class="el" href="classgr_1_1block.html#a0a482fb96a3d7343ffdd86a21538c2e5" title="compute output items from input items ">gr::block::general_work()</a> (note: the arguments mean the same, too), but it's called <code>work</code> like with the other derived block types (such as <a class="el" href="classgr_1_1sync__block.html" title="synchronous 1:1 input to output with historyOverride work to provide the signal processing implementa...">gr::sync_block</a>). Also, there's a new function: <code>calculate_output_stream_length()</code> is, in a sense, the opposite function to <a class="el" href="classgr_1_1block.html#a5bc118d94944d2ff71e378f807fb8d28" title="Estimate input requirements given output request. ">gr::block::forecast()</a>. Given a number of input items, it calculates the required number of output items. Note how this relates to the fact that these blocks are input-driven.</p>
<p>These two overrides (<code>work()</code> and <code>calculate_output_stream_length()</code> ) are what you need for most tagged stream blocks. There are cases when you don't need to override the latter because the default behaviour is enough, and other cases where you have to override more than these two functions. These are discussed in <a class="el" href="page_tagged_stream_blocks.html#tsb_adv_usage">Advanced Usage</a>.</p>
<p>Finally, this is part of the actual block implementation (heavily cropped again, to highlight the relevant parts): </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io__signature_8h.html">gnuradio/io_signature.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;crc32_bb_impl.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>gr {</div>
<div class="line">  <span class="keyword">namespace </span>digital {</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classgr_1_1digital_1_1crc32__bb.html#ab2394a2e5f83cf9a838dd4d65d27f2f2">crc32_bb::sptr</a> <a class="code" href="classgr_1_1digital_1_1crc32__bb.html#ad9041009cc509e8fdc1e732daedde1be">crc32_bb::make</a>(<span class="keywordtype">bool</span> check, <span class="keyword">const</span> std::string&amp; len_tag_key)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> gnuradio::get_initial_sptr (<span class="keyword">new</span> crc32_bb_impl(check, len_tag_key));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    crc32_bb_impl::crc32_bb_impl(<span class="keywordtype">bool</span> check, <span class="keyword">const</span> std::string&amp; len_tag_key)</div>
<div class="line">      : tagged_stream_block(<span class="stringliteral">&quot;crc32_bb&quot;</span>,</div>
<div class="line">                   io_signature::make(2, 1, sizeof (char)),</div>
<div class="line">                   io_signature::make(1, 1, sizeof (char)),</div>
<div class="line">                   len_tag_key),</div>
<div class="line">        d_check(check)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span></div>
<div class="line">    crc32_bb_impl::calculate_output_stream_length(<span class="keyword">const</span> <a class="code" href="gnuradio-runtime_2include_2gnuradio_2types_8h.html#ab02d0a829d67d39e3ac3163016d3a8be">gr_vector_int</a> &amp;ninput_items)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (d_check) {</div>
<div class="line">        <span class="keywordflow">return</span> ninput_items[0] - 4;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> ninput_items[0] + 4;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span></div>
<div class="line">    crc32_bb_impl::work (<span class="keywordtype">int</span> noutput_items,</div>
<div class="line">                       <a class="code" href="gnuradio-runtime_2include_2gnuradio_2types_8h.html#ab02d0a829d67d39e3ac3163016d3a8be">gr_vector_int</a> &amp;ninput_items,</div>
<div class="line">                       <a class="code" href="gnuradio-runtime_2include_2gnuradio_2types_8h.html#a9852a3d906d823cb70eb9c29e7f2a43d">gr_vector_const_void_star</a> &amp;input_items,</div>
<div class="line">                       <a class="code" href="gnuradio-runtime_2include_2gnuradio_2types_8h.html#acd3f499576e769966ea44554b359d949">gr_vector_void_star</a> &amp;output_items)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) input_items[0];</div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) output_items[0];</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Do all the signal processing...</span></div>
<div class="line">      <span class="comment">// Don&#39;t call consume!</span></div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> new_packet_length;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  } <span class="comment">// namespace digital</span></div>
<div class="line">} <span class="comment">// namespace gr</span></div>
</div><!-- fragment --><p>The make function is not different to any other block. The constructor calls <a class="el" href="classgr_1_1tagged__stream__block.html#a6ce6d685bfe6e4ebfe04df9d6a222cbe">gr::tagged_stream_block::tagged_stream_block()</a> as expected, but note that it passes the key of the length tag to the parent constructor.</p>
<p>The block in question is a CRC block, and it has two modes: It can check the CRC (which is then removed), or it can append a CRC to a sequence of bytes. The <code>calculate_output_stream_length()</code> function is thus very simple: depending on how the block is configured, the output is either 4 bytes longer or shorter than the input stream.</p>
<p>The <code>work()</code> function looks very similar to any other work function. When writing the signal processing code, the following things must be kept in mind:</p>
<ul>
<li>The work function is called for exactly one PDU, and no more (or less) may be processed</li>
<li><code>ninput_items</code> contains the exact number of items in this PDU (at every port). These items <em>will</em> be consumed after <code>work()</code> exits.</li>
<li>Don't call <code>consume()</code> or <code>consume_each()</code> yourself! <a class="el" href="classgr_1_1tagged__stream__block.html" title="Block that operates on PDUs in form of tagged streamsOverride work to provide the signal processing i...">gr::tagged_stream_block</a> will do that for you.</li>
<li>You can call <code>produce()</code> or <code>produce_each()</code>, if you're doing something complicated. Don't forget to return WORK_CALLED_PRODUCE in that case.</li>
</ul>
<h2><a class="anchor" id="tsb_note_on_tp"></a>
A note on tag propagation</h2>
<p>Despite using tags for a special purpose, all tags that are not the length tag are treated exactly as before: use <a class="el" href="classgr_1_1block.html#a476e218927e426ac88c26431cbf086cd" title="Set the policy by the scheduler to determine how tags are moved downstream. ">gr::block::set_tag_propagation_policy()</a> in the constructor.</p>
<p>In a lot of the cases, though, you will need to specify set_tag_propagation_policy(TPP_DONT) and manually handle the tag propagation in <code>work()</code>. This is because the unknown length of the PDUs at compile time prohibits us from setting a precise relative rate of the block, which is a requirement for automatic tag propagation. Only if the tagged stream block is also a sync block (including interpolators and decimators, i.e. blocks with an integer rate change), can automatic tag propagation be reliably used.</p>
<p>It is a general rule of GNU Radio blocks that they "properly" propagate tags, whatever this means for a specific application.</p>
<p>The CRC block seems to a very simple block, but it's already complicated enough to confuse the automatic tag propagation. For example, what happens to tags which are on the CRC? Do they get removed, or do they get moved to the last item before the CRC? Also, the input to output rate is different for every PDU length.</p>
<p>In this case, it is necessary for the developer to define a tag propagation policy and implement it in <code>work()</code>. Also, it is good practice to specify that tag propagation policy in the blocks documentation.</p>
<p>The actual length tags <em>are</em> treated differently, though. Most importantly, you don't have to write the new length tag yourself. The key for the output length tag is the same as that on the input, if you don't want this, you must override <a class="el" href="classgr_1_1tagged__stream__block.html#ac28d645a2d5446dc44a41433f77c4d7b" title="Set the new length tags on the output stream. ">gr::tagged_stream_block::update_length_tags()</a>.</p>
<h1><a class="anchor" id="tsb_connecting"></a>
Connecting regular streaming blocks and tagged stream blocks</h1>
<p>From the scheduler's point of view, all blocks are equivalent, and as long as the I/O signatures are compatible, all of these blocks can be connected.</p>
<p>However, it is important to note that tagged stream blocks expect correctly tagged streams, i.e. a length tag with a number of items at the beginning of every packet. If this is not the case, the <em>flow graph will crash</em>. The most common cases are discussed separately:</p>
<p>Connecting a tagged stream block to a regular stream block: This is never a problem, since regular blocks don't care about the values of the tags.</p>
<p>Connecting regular stream blocks to tagged stream blocks: This will usually not work. One solution is to use the <a class="el" href="namespacegr_1_1blocks.html">gr::blocks</a>:stream_to_tagged_stream adapter block. It will periodically add tags at regular intervals, making the input valid for the tagged stream block. Make sure to directly connect this block to the tagged stream block, or the packet size might be changed to a different value from the tag value.</p>
<p>Mixing block types: This is possible if none of the regular stream blocks change the rate. The ofdm_tx and ofdm_rx hierarchical blocks do this.</p>
<h1><a class="anchor" id="tsb_adv_usage"></a>
Advanced Usage</h1>
<p>It is generally recommended to read the block documentation of <a class="el" href="classgr_1_1tagged__stream__block.html" title="Block that operates on PDUs in form of tagged streamsOverride work to provide the signal processing i...">gr::tagged_stream_block</a>.</p>
<p>A few special cases are described here:</p>
<h2><a class="anchor" id="tsb_multiplelentags"></a>
Multiple length tags</h2>
<p>In some cases, a single tag is not enough. One example is the OFDM receiver: one OFDM frame contains a certain number of OFDM symbols, and another number of bytes&ndash;these numbers are only very loosely related, and one cannot be calculated from the other.</p>
<p><a class="el" href="classgr_1_1digital_1_1ofdm__serializer__vcc.html" title="Serializes complex modulations symbols from OFDM sub-carriers. ">gr::digital::ofdm_serializer_vcc</a> is such a block. It is driven by the number of OFDM frames, but the output is determined by the number of complex symbols. In order to use multiple length tag keys, it overrides <a class="el" href="classgr_1_1tagged__stream__block.html#ac28d645a2d5446dc44a41433f77c4d7b" title="Set the new length tags on the output stream. ">gr::tagged_stream_block::update_length_tags()</a>.</p>
<h2><a class="anchor" id="tsb_backtogrblock"></a>
Falling back to gr::block behaviour</h2>
<p>If, at compile-time, it is uncertain whether or not a block should be a <a class="el" href="classgr_1_1tagged__stream__block.html" title="Block that operates on PDUs in form of tagged streamsOverride work to provide the signal processing i...">gr::tagged_stream_block</a>, there is the possibility of falling back to <a class="el" href="classgr_1_1block.html" title="The abstract base class for all &#39;terminal&#39; processing blocks.A signal processing flow is constructed ...">gr::block</a> behaviour.</p>
<p>To do this, simple don't pass an empty string as length tag key. Instead of crashing, a tagged stream block will behave like a <a class="el" href="classgr_1_1block.html" title="The abstract base class for all &#39;terminal&#39; processing blocks.A signal processing flow is constructed ...">gr::block</a>.</p>
<p>This has some consequences: The work function must have all the elements of a <a class="el" href="classgr_1_1block.html#a0a482fb96a3d7343ffdd86a21538c2e5" title="compute output items from input items ">gr::block::general_work()</a> function, including calls to consume(). Because such a block must allow both modes of operation (PDUs with tags, and infinite-stream), the work function must check which mode is currently relevant. Checking if <a class="el" href="classgr_1_1tagged__stream__block.html#a003c792d041aa3caa9543762f2597d41">gr::tagged_stream_block::d_length_tag_key_str</a> is empty is a good choice.</p>
<p><a class="el" href="classgr_1_1digital_1_1ofdm__cyclic__prefixer.html" title="Adds a cyclic prefix and performs pulse shaping on OFDM symbols. ">gr::digital::ofdm_cyclic_prefixer</a> implements this.</p>
<h2><a class="anchor" id="tsb_otherwaysdetermineninput"></a>
Other ways to determine the number of input items</h2>
<p>If the number of input items is not stored as a pmt::pmt_integer, but there is a way to determine it, <a class="el" href="classgr_1_1tagged__stream__block.html#aa8e90da8146969d14006474b4594e7ed" title="Parse all tags on the first sample of a PDU, return the number of items per input and prune the lengt...">gr::tagged_stream_block::parse_length_tags()</a> can be overridden to figure out the length of the PDU.</p>
<h1><a class="anchor" id="tsb_examples"></a>
Examples</h1>
<h2><a class="anchor" id="tsb_CRC32"></a>
CRC32</h2>
<p>Block: <a class="el" href="classgr_1_1digital_1_1crc32__bb.html" title="Byte-stream CRC block. ">gr::digital::crc32_bb</a></p>
<p>This is a very simple block, and a good example to start with.</p>
<h2><a class="anchor" id="tsb_ofdmeq"></a>
OFDM Frame Equalizer</h2>
<p>Block: <a class="el" href="classgr_1_1digital_1_1ofdm__frame__equalizer__vcvc.html" title="OFDM frame equalizer. ">gr::digital::ofdm_frame_equalizer_vcvc</a></p>
<p>This block would be a sync block if tagged stream blocks didn't exist. It also uses more than one tag to determine the output.</p>
<h2><a class="anchor" id="tsb_muxer"></a>
Tagged Stream Muxer</h2>
<p>Block: <a class="el" href="classgr_1_1blocks_1_1tagged__stream__mux.html" title="Combines tagged streams. ">gr::blocks::tagged_stream_mux</a></p>
<p>Use this to multiplex any number of tagged streams.</p>
<h2><a class="anchor" id="tsb_ofdmprefixer"></a>
Cyclic Prefixer (OFDM)</h2>
<p>Block: <a class="el" href="classgr_1_1digital_1_1ofdm__cyclic__prefixer.html" title="Adds a cyclic prefix and performs pulse shaping on OFDM symbols. ">gr::digital::ofdm_cyclic_prefixer</a></p>
<p>This block uses the <a class="el" href="classgr_1_1block.html" title="The abstract base class for all &#39;terminal&#39; processing blocks.A signal processing flow is constructed ...">gr::block</a> behaviour fallback.</p>
<h1><a class="anchor" id="tsb_troubleshooting"></a>
Troubleshooting</h1>
<p><b>My flow graph crashes with the error message "Missing length tag".</b></p>
<p>This means the input of a tagged stream block was not correctly tagged. The most common cause is when connecting a regular streaming block to a tagged stream block. You can check the log output for the item number and port where this happened. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
