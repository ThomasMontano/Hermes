<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="page_packet_data" kind="page">
    <compoundname>page_packet_data</compoundname>
    <title>Packet Data Transmission</title>
    <detaileddescription>
<sect1 id="page_packet_data_1packet_data_introduction">
<title>Introduction</title>
<para>In many cases, the PHY layer of a digital transceiver uses <emphasis>packets</emphasis>to break down the transmission (as opposed to continuously broadcasting data), and GNU Radio natively supports this kind of transmission. The basic mechanisms which allow this are the <ref refid="page_msg_passing" kindref="compound">Message Passing</ref> and the <ref refid="page_tagged_stream_blocks" kindref="compound">Tagged Stream Blocks</ref>.</para><para>With the tools provided in GNU Radio, simple digital packet transmission schemes are easily implemented, allowing the creation of packet-based communication links and even -networks.</para></sect1>
<sect1 id="page_packet_data_1packet_data_structure">
<title>Structure of a packet</title>
<para>Typically, a packet consists of the following elements:</para><para><itemizedlist>
<listitem><para>A preamble. This is used for detection, synchronization (in time and frequency) and possibly initial channel state estimation.</para></listitem><listitem><para>A header. This is of fixed length and stores information about the packet, such as (most importantly) its length, but potentially other information, such as the packet number, its intended recipient etc.</para></listitem><listitem><para>The payload.</para></listitem><listitem><para>A checksum, typically a CRC value, to validate the packet contents.</para></listitem></itemizedlist>
</para><para>At the transmitter stage, these are modulated and prepared for transmission (a forward error correction code may also be applied). Because the transmitter knows the packet length, is a trivial matter to create the transmit frames using the tagged stream blocks.</para><para>The receiver has to perform a multitude of things to obtain the packet again. Most importantly, it has to convert an infinite stream (coming from the receiver device, e.g. a UHD source block) into a packetized, tagged stream.</para></sect1>
<sect1 id="page_packet_data_1packet_data_hpdemuxer">
<title>The Header/Payload Demuxer and header parser</title>
<para>The key element to return back to packetized state is the <ref refid="classgr_1_1digital_1_1header__payload__demux" kindref="compound">gr::digital::header_payload_demux</ref>. At its first input, it receives a continuous stream of sample data, coming from the receiver device. It discards all the incoming samples, until the beginning of a packet is signalled, either by a stream tag, or a trigger signal on its second input.</para><para>Once such a beginning is detected, the demultiplexer copies the preamble and header to the first output (it must know the exact length of these elements). The header can then be demodulated with any suitable set of GNU Radio blocks.</para><para>To turn the information stored in the demodulated header bits into metadata which can be understood by GNU Radio, a <ref refid="classgr_1_1digital_1_1packet__headerparser__b" kindref="compound">gr::digital::packet_headerparser_b</ref> block is used to turn the header data into a message, which is passed back to the header/payload demuxer. The latter then knows the length of the payload, and passes that out on the second output, along with all the metadata obtained in the header demodulation chain.</para><para>The knowledge of the header structure (i.e. how to turn a sequence of bits into a payload length etc.) is stored in an object of type <ref refid="classgr_1_1digital_1_1packet__header__default" kindref="compound">gr::digital::packet_header_default</ref>. This must be passed to the header parser block.</para></sect1>
<sect1 id="page_packet_data_1packet_data_ofdm">
<title>Packet receiver example: OFDM</title>
<para><image type="html" name="example_ofdm_packet_rx.png">Example: OFDM Packet Receiver</image>
 The image above shows an example of a simple OFDM receiver. It has no forward error correction, and uses the simplest possible frame structure.</para><para>The four elements of the packet receiver are highlighted. The first part is the packet detector and synchronizer. The samples piped into the header/payload demuxer are fine frequency corrected, and a trigger signal is sent to mark the beginning of the burst.</para><para>Next, the header demodulation receiver chain is activated. The FFT shifts OFDM symbols to the frequency domain. The coarse frequency offset and initial channel state are estimated from the preamble and are added to the stream as tags. The OFDM symbol containing the header is passed to an equalizer, which also corrects the coarse frequency offset. A serializer picks the data symbols from the OFDM symbol and outputs them as a sequence of scalar complex values, which are then demodulated into bits (in this case BPSK is used).</para><para>The bits are interpreted by the header parser, which uses a <ref refid="classgr_1_1digital_1_1packet__header__ofdm" kindref="compound">gr::digital::packet_header_ofdm</ref> object to interpret the bits (the latter is derived form <ref refid="classgr_1_1digital_1_1packet__header__default" kindref="compound">gr::digital::packet_header_default</ref>). The result from the header parser is then fed back to the demuxer, which now knows the length of payload and outputs that as a tagged stream.</para><para>The payload demodulation chain is the same as the header demodulation chain, only the channel estimator block is unnecessary as the channel state information is still available as metadata on the payload tagged stream.</para><para>This flow graph, as well as the corresponding transmitter, can be found in gr-digital/examples/ofdm/rx_ofdm.grc and gr-digital/examples/ofdm/tx_ofdm.grc </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
