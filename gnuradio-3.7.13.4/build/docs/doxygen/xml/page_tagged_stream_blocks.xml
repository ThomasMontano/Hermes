<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="page_tagged_stream_blocks" kind="page">
    <compoundname>page_tagged_stream_blocks</compoundname>
    <title>Tagged Stream Blocks</title>
    <detaileddescription>
<sect1 id="page_tagged_stream_blocks_1tsb_introduction">
<title>Introduction</title>
<para>A tagged stream block is a block that works on streamed, but packetized input data. Think of packet data transmission: A data packet consists of N bytes. However, in traditional GNU Radio blocks, if we stream N bytes into a block, there&apos;s no way of knowing the packet boundary. This might be relevant: Perhaps the modulator has to prepend a synchronisation word before every packet, or append a CRC. So while some blocks don&apos;t care about packet boundaries, other blocks do: These are <emphasis>tagged stream blocks</emphasis>.</para><para>These blocks are different from all the other GNU Radio block types (<ref refid="classgr_1_1block" kindref="compound">gr::block</ref>, <ref refid="classgr_1_1sync__block" kindref="compound">gr::sync_block</ref> etc.) in that they are driven by the input: The PDU length tag tells the block how to operate, whereas other blocks are output-driven (the scheduler tries to fill up the output buffer are much as possible).</para><sect2 id="page_tagged_stream_blocks_1tsb_howtheywork">
<title>How do they work?</title>
<para>As the name implies, tagged stream blocks use tags to identify PDU boundaries. On the first item of a streamed PDU, there <emphasis>must</emphasis> be a tag with a specific key, which stores the length of the PDU as a PMT integer. If anything else, or no tag, is on this first item, this will cause the flow graph to crash!</para><para>The scheduler then takes care of everything. When the work function is called, it is guaranteed to contain exactly one complete PDU and enough space in the output buffer for the output.</para></sect2>
<sect2 id="page_tagged_stream_blocks_1tsb_relatestootherblocks">
<title>How do they relate to other block types (e.g. sync blocks)?</title>
<para>Tagged stream blocks and sync blocks are really orthogonal concepts, and a block could be both (<ref refid="classgr_1_1digital_1_1ofdm__frame__equalizer__vcvc" kindref="compound">gr::digital::ofdm_frame_equalizer_vcvc</ref> is such a block). However, because the work function is defined differently in these block types, there is no way to derive a block from both <ref refid="classgr_1_1tagged__stream__block" kindref="compound">gr::tagged_stream_block</ref> and <ref refid="classgr_1_1sync__block" kindref="compound">gr::sync_block</ref>.</para><para>If a block needs the tagged stream mechanism (i.e. knowing about PDU boundaries), it must be derived from <ref refid="classgr_1_1tagged__stream__block" kindref="compound">gr::tagged_stream_block</ref>. If it&apos;s also a sync block, it is still possible to set <ref refid="classgr_1_1block_1aff3003eea3517dd3e8d9a5297c1196b1" kindref="member">gr::block::set_relative_rate</ref>(1.0) and/or the fixed rate functions.</para><para>The way <ref refid="classgr_1_1tagged__stream__block" kindref="compound">gr::tagged_stream_block</ref> works, it is still beneficial to specify a relative rate, if possible.</para></sect2>
</sect1>
<sect1 id="page_tagged_stream_blocks_1tsb_creating">
<title>Creating a tagged stream block</title>
<para>To create a tagged stream block, the block must be derived from <ref refid="classgr_1_1tagged__stream__block" kindref="compound">gr::tagged_stream_block</ref>. Here&apos;s a minimal example of how the header file could look: <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="gr-digital_2include_2gnuradio_2digital_2api_8h" kindref="compound">gnuradio/digital/api.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="tagged__stream__block_8h" kindref="compound">gnuradio/tagged_stream_block.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">gr<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">digital<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="gr-digital_2include_2gnuradio_2digital_2api_8h_1ae14969f36ec69051c4b2f13a0db7e9ba" kindref="member">DIGITAL_API</ref><sp/>crc32_bb<sp/>:<sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>tagged_stream_block</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::shared_ptr&lt;crc32_bb&gt;<sp/>sptr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>sptr<sp/>make(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>check=</highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>len_tag_key=</highlight><highlight class="stringliteral">&quot;packet_len&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>digital</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>gr</highlight></codeline>
</programlisting></para><para>It is very similar to any other block definition. Two things are stand out: First, <ref refid="tagged__stream__block_8h" kindref="compound">gnuradio/tagged_stream_block.h</ref> is included to allow deriving from <ref refid="classgr_1_1tagged__stream__block" kindref="compound">gr::tagged_stream_block</ref>.</para><para>The other thing is in the make function: the second argument is a string containing the key of the length tags. This is not necessary (the block could get this information hard-coded), but the usual way is to allow the user to change this tag, but give a default value (in this case, <computeroutput>packet_len</computeroutput>).</para><para>The implementation header (*_impl.h) also looks a bit different (again this is cropped to the relevant parts): <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="crc32__bb_8h" kindref="compound">digital/crc32_bb.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">gr<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">digital<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">crc32_bb_impl<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>crc32_bb</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>crc32_bb_impl(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>check,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>len_tag_key);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>~crc32_bb_impl();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>calculate_output_stream_length(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="gnuradio-runtime_2include_2gnuradio_2types_8h_1ab02d0a829d67d39e3ac3163016d3a8be" kindref="member">gr_vector_int</ref><sp/>&amp;ninput_items);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>work(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>noutput_items,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="gnuradio-runtime_2include_2gnuradio_2types_8h_1ab02d0a829d67d39e3ac3163016d3a8be" kindref="member">gr_vector_int</ref><sp/>&amp;ninput_items,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="gnuradio-runtime_2include_2gnuradio_2types_8h_1a9852a3d906d823cb70eb9c29e7f2a43d" kindref="member">gr_vector_const_void_star</ref><sp/>&amp;input_items,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="gnuradio-runtime_2include_2gnuradio_2types_8h_1acd3f499576e769966ea44554b359d949" kindref="member">gr_vector_void_star</ref><sp/>&amp;output_items);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>digital</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>gr</highlight></codeline>
</programlisting></para><para>First, the <computeroutput>work</computeroutput> function signature is new. The argument list looks like that from <ref refid="classgr_1_1block_1a0a482fb96a3d7343ffdd86a21538c2e5" kindref="member">gr::block::general_work()</ref> (note: the arguments mean the same, too), but it&apos;s called <computeroutput>work</computeroutput> like with the other derived block types (such as <ref refid="classgr_1_1sync__block" kindref="compound">gr::sync_block</ref>). Also, there&apos;s a new function: <computeroutput>calculate_output_stream_length()</computeroutput> is, in a sense, the opposite function to <ref refid="classgr_1_1block_1a5bc118d94944d2ff71e378f807fb8d28" kindref="member">gr::block::forecast()</ref>. Given a number of input items, it calculates the required number of output items. Note how this relates to the fact that these blocks are input-driven.</para><para>These two overrides (<computeroutput>work()</computeroutput> and <computeroutput>calculate_output_stream_length()</computeroutput> ) are what you need for most tagged stream blocks. There are cases when you don&apos;t need to override the latter because the default behaviour is enough, and other cases where you have to override more than these two functions. These are discussed in <ref refid="page_tagged_stream_blocks_1tsb_adv_usage" kindref="member">Advanced Usage</ref>.</para><para>Finally, this is part of the actual block implementation (heavily cropped again, to highlight the relevant parts): <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="io__signature_8h" kindref="compound">gnuradio/io_signature.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;crc32_bb_impl.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">gr<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">digital<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classgr_1_1digital_1_1crc32__bb_1ab2394a2e5f83cf9a838dd4d65d27f2f2" kindref="member">crc32_bb::sptr</ref><sp/><ref refid="classgr_1_1digital_1_1crc32__bb_1ad9041009cc509e8fdc1e732daedde1be" kindref="member">crc32_bb::make</ref>(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>check,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>len_tag_key)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>gnuradio::get_initial_sptr<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>crc32_bb_impl(check,<sp/>len_tag_key));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>crc32_bb_impl::crc32_bb_impl(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>check,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>len_tag_key)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>tagged_stream_block(</highlight><highlight class="stringliteral">&quot;crc32_bb&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>io_signature::make(2,<sp/>1,<sp/>sizeof<sp/>(char)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>io_signature::make(1,<sp/>1,<sp/>sizeof<sp/>(char)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>len_tag_key),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>d_check(check)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>crc32_bb_impl::calculate_output_stream_length(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="gnuradio-runtime_2include_2gnuradio_2types_8h_1ab02d0a829d67d39e3ac3163016d3a8be" kindref="member">gr_vector_int</ref><sp/>&amp;ninput_items)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(d_check)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ninput_items[0]<sp/>-<sp/>4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ninput_items[0]<sp/>+<sp/>4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>crc32_bb_impl::work<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>noutput_items,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="gnuradio-runtime_2include_2gnuradio_2types_8h_1ab02d0a829d67d39e3ac3163016d3a8be" kindref="member">gr_vector_int</ref><sp/>&amp;ninput_items,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="gnuradio-runtime_2include_2gnuradio_2types_8h_1a9852a3d906d823cb70eb9c29e7f2a43d" kindref="member">gr_vector_const_void_star</ref><sp/>&amp;input_items,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="gnuradio-runtime_2include_2gnuradio_2types_8h_1acd3f499576e769966ea44554b359d949" kindref="member">gr_vector_void_star</ref><sp/>&amp;output_items)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*in<sp/>=<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*)<sp/>input_items[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*out<sp/>=<sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*)<sp/>output_items[0];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Do<sp/>all<sp/>the<sp/>signal<sp/>processing...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Don&apos;t<sp/>call<sp/>consume!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>new_packet_length;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>digital</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>gr</highlight></codeline>
</programlisting></para><para>The make function is not different to any other block. The constructor calls <ref refid="classgr_1_1tagged__stream__block_1a6ce6d685bfe6e4ebfe04df9d6a222cbe" kindref="member">gr::tagged_stream_block::tagged_stream_block()</ref> as expected, but note that it passes the key of the length tag to the parent constructor.</para><para>The block in question is a CRC block, and it has two modes: It can check the CRC (which is then removed), or it can append a CRC to a sequence of bytes. The <computeroutput>calculate_output_stream_length()</computeroutput> function is thus very simple: depending on how the block is configured, the output is either 4 bytes longer or shorter than the input stream.</para><para>The <computeroutput>work()</computeroutput> function looks very similar to any other work function. When writing the signal processing code, the following things must be kept in mind:<itemizedlist>
<listitem><para>The work function is called for exactly one PDU, and no more (or less) may be processed</para></listitem><listitem><para><computeroutput>ninput_items</computeroutput> contains the exact number of items in this PDU (at every port). These items <emphasis>will</emphasis> be consumed after <computeroutput>work()</computeroutput> exits.</para></listitem><listitem><para>Don&apos;t call <computeroutput>consume()</computeroutput> or <computeroutput>consume_each()</computeroutput> yourself! <ref refid="classgr_1_1tagged__stream__block" kindref="compound">gr::tagged_stream_block</ref> will do that for you.</para></listitem><listitem><para>You can call <computeroutput>produce()</computeroutput> or <computeroutput>produce_each()</computeroutput>, if you&apos;re doing something complicated. Don&apos;t forget to return WORK_CALLED_PRODUCE in that case.</para></listitem></itemizedlist>
</para><sect2 id="page_tagged_stream_blocks_1tsb_note_on_tp">
<title>A note on tag propagation</title>
<para>Despite using tags for a special purpose, all tags that are not the length tag are treated exactly as before: use <ref refid="classgr_1_1block_1a476e218927e426ac88c26431cbf086cd" kindref="member">gr::block::set_tag_propagation_policy()</ref> in the constructor.</para><para>In a lot of the cases, though, you will need to specify set_tag_propagation_policy(TPP_DONT) and manually handle the tag propagation in <computeroutput>work()</computeroutput>. This is because the unknown length of the PDUs at compile time prohibits us from setting a precise relative rate of the block, which is a requirement for automatic tag propagation. Only if the tagged stream block is also a sync block (including interpolators and decimators, i.e. blocks with an integer rate change), can automatic tag propagation be reliably used.</para><para>It is a general rule of GNU Radio blocks that they &quot;properly&quot; propagate tags, whatever this means for a specific application.</para><para>The CRC block seems to a very simple block, but it&apos;s already complicated enough to confuse the automatic tag propagation. For example, what happens to tags which are on the CRC? Do they get removed, or do they get moved to the last item before the CRC? Also, the input to output rate is different for every PDU length.</para><para>In this case, it is necessary for the developer to define a tag propagation policy and implement it in <computeroutput>work()</computeroutput>. Also, it is good practice to specify that tag propagation policy in the blocks documentation.</para><para>The actual length tags <emphasis>are</emphasis> treated differently, though. Most importantly, you don&apos;t have to write the new length tag yourself. The key for the output length tag is the same as that on the input, if you don&apos;t want this, you must override <ref refid="classgr_1_1tagged__stream__block_1ac28d645a2d5446dc44a41433f77c4d7b" kindref="member">gr::tagged_stream_block::update_length_tags()</ref>.</para></sect2>
</sect1>
<sect1 id="page_tagged_stream_blocks_1tsb_connecting">
<title>Connecting regular streaming blocks and tagged stream blocks</title>
<para>From the scheduler&apos;s point of view, all blocks are equivalent, and as long as the I/O signatures are compatible, all of these blocks can be connected.</para><para>However, it is important to note that tagged stream blocks expect correctly tagged streams, i.e. a length tag with a number of items at the beginning of every packet. If this is not the case, the <emphasis>flow graph will crash</emphasis>. The most common cases are discussed separately:</para><para>Connecting a tagged stream block to a regular stream block: This is never a problem, since regular blocks don&apos;t care about the values of the tags.</para><para>Connecting regular stream blocks to tagged stream blocks: This will usually not work. One solution is to use the <ref refid="namespacegr_1_1blocks" kindref="compound">gr::blocks</ref>:stream_to_tagged_stream adapter block. It will periodically add tags at regular intervals, making the input valid for the tagged stream block. Make sure to directly connect this block to the tagged stream block, or the packet size might be changed to a different value from the tag value.</para><para>Mixing block types: This is possible if none of the regular stream blocks change the rate. The ofdm_tx and ofdm_rx hierarchical blocks do this.</para></sect1>
<sect1 id="page_tagged_stream_blocks_1tsb_adv_usage">
<title>Advanced Usage</title>
<para>It is generally recommended to read the block documentation of <ref refid="classgr_1_1tagged__stream__block" kindref="compound">gr::tagged_stream_block</ref>.</para><para>A few special cases are described here:</para><sect2 id="page_tagged_stream_blocks_1tsb_multiplelentags">
<title>Multiple length tags</title>
<para>In some cases, a single tag is not enough. One example is the OFDM receiver: one OFDM frame contains a certain number of OFDM symbols, and another number of bytes<ndash/>these numbers are only very loosely related, and one cannot be calculated from the other.</para><para><ref refid="classgr_1_1digital_1_1ofdm__serializer__vcc" kindref="compound">gr::digital::ofdm_serializer_vcc</ref> is such a block. It is driven by the number of OFDM frames, but the output is determined by the number of complex symbols. In order to use multiple length tag keys, it overrides <ref refid="classgr_1_1tagged__stream__block_1ac28d645a2d5446dc44a41433f77c4d7b" kindref="member">gr::tagged_stream_block::update_length_tags()</ref>.</para></sect2>
<sect2 id="page_tagged_stream_blocks_1tsb_backtogrblock">
<title>Falling back to gr::block behaviour</title>
<para>If, at compile-time, it is uncertain whether or not a block should be a <ref refid="classgr_1_1tagged__stream__block" kindref="compound">gr::tagged_stream_block</ref>, there is the possibility of falling back to <ref refid="classgr_1_1block" kindref="compound">gr::block</ref> behaviour.</para><para>To do this, simple don&apos;t pass an empty string as length tag key. Instead of crashing, a tagged stream block will behave like a <ref refid="classgr_1_1block" kindref="compound">gr::block</ref>.</para><para>This has some consequences: The work function must have all the elements of a <ref refid="classgr_1_1block_1a0a482fb96a3d7343ffdd86a21538c2e5" kindref="member">gr::block::general_work()</ref> function, including calls to consume(). Because such a block must allow both modes of operation (PDUs with tags, and infinite-stream), the work function must check which mode is currently relevant. Checking if <ref refid="classgr_1_1tagged__stream__block_1a003c792d041aa3caa9543762f2597d41" kindref="member">gr::tagged_stream_block::d_length_tag_key_str</ref> is empty is a good choice.</para><para><ref refid="classgr_1_1digital_1_1ofdm__cyclic__prefixer" kindref="compound">gr::digital::ofdm_cyclic_prefixer</ref> implements this.</para></sect2>
<sect2 id="page_tagged_stream_blocks_1tsb_otherwaysdetermineninput">
<title>Other ways to determine the number of input items</title>
<para>If the number of input items is not stored as a pmt::pmt_integer, but there is a way to determine it, <ref refid="classgr_1_1tagged__stream__block_1aa8e90da8146969d14006474b4594e7ed" kindref="member">gr::tagged_stream_block::parse_length_tags()</ref> can be overridden to figure out the length of the PDU.</para></sect2>
</sect1>
<sect1 id="page_tagged_stream_blocks_1tsb_examples">
<title>Examples</title>
<sect2 id="page_tagged_stream_blocks_1tsb_CRC32">
<title>CRC32</title>
<para>Block: <ref refid="classgr_1_1digital_1_1crc32__bb" kindref="compound">gr::digital::crc32_bb</ref></para><para>This is a very simple block, and a good example to start with.</para></sect2>
<sect2 id="page_tagged_stream_blocks_1tsb_ofdmeq">
<title>OFDM Frame Equalizer</title>
<para>Block: <ref refid="classgr_1_1digital_1_1ofdm__frame__equalizer__vcvc" kindref="compound">gr::digital::ofdm_frame_equalizer_vcvc</ref></para><para>This block would be a sync block if tagged stream blocks didn&apos;t exist. It also uses more than one tag to determine the output.</para></sect2>
<sect2 id="page_tagged_stream_blocks_1tsb_muxer">
<title>Tagged Stream Muxer</title>
<para>Block: <ref refid="classgr_1_1blocks_1_1tagged__stream__mux" kindref="compound">gr::blocks::tagged_stream_mux</ref></para><para>Use this to multiplex any number of tagged streams.</para></sect2>
<sect2 id="page_tagged_stream_blocks_1tsb_ofdmprefixer">
<title>Cyclic Prefixer (OFDM)</title>
<para>Block: <ref refid="classgr_1_1digital_1_1ofdm__cyclic__prefixer" kindref="compound">gr::digital::ofdm_cyclic_prefixer</ref></para><para>This block uses the <ref refid="classgr_1_1block" kindref="compound">gr::block</ref> behaviour fallback.</para></sect2>
</sect1>
<sect1 id="page_tagged_stream_blocks_1tsb_troubleshooting">
<title>Troubleshooting</title>
<para><bold>My flow graph crashes with the error message &quot;Missing length tag&quot;.</bold></para><para>This means the input of a tagged stream block was not correctly tagged. The most common cause is when connecting a regular streaming block to a tagged stream block. You can check the log output for the item number and port where this happened. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
