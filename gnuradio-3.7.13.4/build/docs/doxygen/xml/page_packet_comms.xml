<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="page_packet_comms" kind="page">
    <compoundname>page_packet_comms</compoundname>
    <title>Packet Communications</title>
    <detaileddescription>
<sect1 id="page_packet_comms_1packet_introduction">
<title>Introduction</title>
<para>This page describes...</para><para>The point of these examples and the work is to provide a canonical tool for exploring burst digital communications. Providing the entire PHY chain in GRC is to help us more easily explore and extract portions of the transmit and receive chains to better understand, tweak, and optimize the system.</para></sect1>
<sect1 id="page_packet_comms_1packet_tx">
<title>Understanding the Transmitter</title>
<para>The transmitter PHY layer defines the following properties of the transmitted frame:</para><para><itemizedlist>
<listitem><para>Data integrity check, generally a <ref refid="classgr_1_1digital_1_1crc32__async__bb" kindref="compound">CRC</ref>. Standard practice would be to calculate a CRC32 of the payload and append this to the end of the frame.</para></listitem><listitem><para><ref refid="page_fec" kindref="compound">Forward Error Correction (FEC)</ref>. For correcting bit errors during reception, we use FEC codes, which have different properties for complexity, correcting capabilities, and amounts of added redundancy. See our <ref refid="page_fec" kindref="compound">FEC-API page</ref> in the manual for more on how to use these and what types of codes are already available.</para></listitem><listitem><para>Frame formatting. We expect the data to have been delivered to the transmitter from some higher layer (MAC/Network), which we treat as the payload. The PHY layer then puts on a bit of its own framing in order to properly transmit it for other radios to receive correctly. This often involves some information about the payload format, such as the length, the type of FEC code used, and the type of modulation or modulation parameters. The PHY layer frame will also often add a known word to the front to help with synchronization and identification. We use the Packet Header Formatter block for this, which is completely defined by a packet formatter object. See the <ref refid="classgr_1_1digital_1_1header__format__base" kindref="compound">gr::digital::header_format_base</ref> class to understand more about how these formatters are created and used.</para><para>The <ref refid="classgr_1_1digital_1_1protocol__formatter__async" kindref="compound">Protocol Formatter</ref> has two output paths, both emitted as PDUs from message ports. The first message port is &quot;header&quot; that emits the header created for the payload based on the formatter object. The second message port is &quot;payload&quot; which is just the input payload PDU re-emitted. This creates two paths, which allows us to separately modulate the header and payload differently as well as encode the header with a different FEC code. We often want to do this to provide a much simpler and more robust modulation and FEC structure to the header to ensure that it is correctly received and then use a different modulation and code for the payload to maximize throughput.</para><para>NOTE: If the header formatter adds the known word / access code here, and then we apply an FEC code to the header, then we have the problem that the known word is also encoded. The receiver must be made aware of this and correctly look for the encoded known word. The packet_tx hier block example is a case where this happens. If we use a repetition encoder, the access code is now three bits out for every bit in. The packet_rx receiver example has to account for this in the Correlation Estimator block that is correlating against the known word.</para></listitem><listitem><para>Modulators. We create a modulator path for both the header and payload. We define the operations of these two paths completely using a <ref refid="classgr_1_1digital_1_1constellation" kindref="compound">Constellation Object</ref> (see the <ref refid="page_digital_1digital_constellations" kindref="member">Digital Modulation</ref> manual page for more information). The constellation objects define the mapping from bits to complex symbols. You can use these objects in various ways, but the packet_tx.grc example provides one way. After moving from the PDU to tagged stream mode, the <ref refid="classgr_1_1blocks_1_1repack__bits__bb" kindref="compound">Repack Bits block</ref> takes the packed 8-bits/byte data and converts this into &quot;chunks&quot; of the number of bits per symbol of the modulation (using the <ref refid="classgr_1_1digital_1_1constellation_1ae5322f145b0af1fb23010aa3da589e9f" kindref="member">bits_per_symbol()</ref> property of the constellation object). We then map these chunks into some known mapping function, most often a form of Gray Coding, using the <ref refid="classgr_1_1digital_1_1map__bb" kindref="compound">Map block</ref> and the constellation object&apos;s <ref refid="classgr_1_1digital_1_1constellation_1a12c074528343a796a8b4c79be05bed5e" kindref="member">pre_diff_code()</ref> function. We then move these remapped chunks to complex symbols, again as defined by the constellation object through the <ref refid="classgr_1_1digital_1_1constellation_1a27ba0660bcd984420d0a095dd0cf2d19" kindref="member">points()</ref> function in the Chunks to Symbols block.</para></listitem><listitem><para>Combine the header and payload. We need to take both the header and payload paths back together into a single stream. In packet_tx.grc, we are working with tagged streams, so both paths keep track of the size of their segments. Using the Tagged Stream Mux block, we recombine these two paths into one.</para></listitem><listitem><para>Burst Shaping and Filtering. The next stage shapes the packet for burst transmission. We apply two blocks to shape the burst appropriately.</para><para>First, the Burst Shaping block handles the structure of the burst by applying two different forms of padding. First, there is a window that is applied to the time domain of the burst. This involves a ramping up stage from 0 and a ramping down stage back to 0. We define a window as a vector, and the <ref refid="classgr_1_1fft_1_1window" kindref="compound">fft.window</ref> set of window functions is useful here, such as using a Hann or Kaiser window. The size of the window is split in half to apply the left half of the window for the ramp-up and the right half of the window for the ramp-down. The window has two different modes: to insert or not insert phasing symbols. When inserting phasing symbols, a sequence of 1&apos;s and -1&apos;s is inserted for the duration of the ramp-up and ramp-down periods. So a window size of 20 will produce 10 alternative 1&apos;s and -1&apos;s on the front of the burst and another 10 alternating symbols on the rear of the burst. The window is then applied to these phasing symbols and does not affect the burst symbols directly. If we are not using the phasing symbols, the the window is applied to the front and back of the burst directly.</para><para>The Burst Shaper can also add padded 0&apos;s to the front or back of the burst. This allows us to provide some extra control over the structure of the burst. In particular, it can be useful to add post-padding 0&apos;s that is the length of the delay of the pulse shaping filter that will come next. This makes sure that the full burst of samples is pushed through the filter and transmitted completely.</para></listitem></itemizedlist>
</para><para><verbatim>                      ____________________
                     /                    \
                    /                      \
                   /                        \
            ______/                          \____
            |  E  | D |        C         | B | A |

  A: Pre-padding 0&apos;s
  B: Ramp-up window
  C: Frame
  D: Ramp-down window
  E: Post-padding 0&apos;s
</verbatim></para><para>When using phasing symbols, C is the entire frame and sections B and D are filled with alternative 1&apos;s and -1&apos;s.</para><para>When not using phase symbols, the frame extends B through C to D.</para><para>After creating this burst shape, we then put the burst through a pulse shaping filter. This filter both shapes the complex samples into appropriate symbols for transmission based on a spectral mask as well as up-samples the burst to the specified number of samples per symbol. In packet_tx, we are using a Polyphase Arbitrary Resampler to perform this task for us, which means that we can specify and real value for the number of samples/symbol, as long as it is greater than or equal to 2.0.</para><para>Typical pulse shape filters are <ref refid="classgr_1_1filter_1_1firdes_1af37a0f8f92f1e0440033ccdb118df990" kindref="member">Root Raised Cosine (RRC)</ref> filters and <ref refid="classgr_1_1filter_1_1firdes_1aa851ebbcb1f36c54f1db27149f487ee4" kindref="member">Gaussian</ref> filters.</para><para>Because the pulse shape filter up-samples, in packet_tx, we use a <ref refid="classgr_1_1blocks_1_1tagged__stream__multiply__length" kindref="compound">Tagged Stream Multiply Length Tag block</ref>. The resampler block knows nothing about tagged streams, so when it up-samples, the <ref refid="page_tagged_stream_blocks" kindref="compound">tagged stream block (TSB)</ref> tag value does not change. We need to change this tag&apos;s value, too, and so we use the multiply length tag block for this purpose. This is helpful when working with UHD devices, like in uhd_packet_tx.grc, because we can explicitly tell the UHD USRP Sink block to expect a tagged stream to manage the transmission of the burst.</para><sect2 id="page_packet_comms_1packet_tx_params">
<title>Parameters of the packet_tx Example</title>
<para>The canonical example for handling narrowband M-PSK or M-QAM is the packet_tx.grc hierarchical block.</para><para><itemizedlist>
<listitem><para>Header FEC Code (hdr_enc)</para></listitem><listitem><para>Payload FEC Code (pld_enc)</para></listitem><listitem><para>Header Constellation Object (hdr_const)</para></listitem><listitem><para>Payload Constellation Object (pld_const)</para></listitem><listitem><para>Protocol Formatter Object (formatter)</para></listitem><listitem><para>Samples per symbol (sps as a float)</para></listitem><listitem><para>Pulse shaping filter (psf_taps, designed for the polyphase arbitrary resampler)</para></listitem></itemizedlist>
</para><para>We can see all of these objects and settings in the packet_loopback_hier.grc example and uhd_packet_tx.grc if using a UHD-compatibly radio front end.</para></sect2>
<sect2 id="page_packet_comms_1packet_tx_examples">
<title>Examples</title>
<para>The following examples exist to showcase how to control each stage of the transmit processing.</para><para><itemizedlist>
<listitem><para>tx_stage0.grc: simple creation of PDUs to input into the transmitter. By default, this generates <ref refid="classgr_1_1blocks_1_1random__pdu" kindref="compound">random PDUs</ref> for testing. However, we can switch in the <ref refid="classgr_1_1blocks_1_1tuntap__pdu" kindref="compound">TUNTAP PDU</ref> block to create a tun or tap device as the input of samples from some OS application. Note that you will need root privileges to create a tun/tap device and configure it.</para></listitem><listitem><para>tx_stage1.grc: Adding a CRC to the frame. The Message Debug prints the before and after adding the <ref refid="classgr_1_1digital_1_1crc32__async__bb" kindref="compound">CRC32</ref>, so we can see the original PDU and then the PDU with the added 4 bytes of check.</para></listitem><listitem><para>tx_stage2.grc: Adding <ref refid="page_fec" kindref="compound">forward error correction</ref>. This adds an <ref refid="classgr_1_1fec_1_1async__encoder" kindref="compound">FEC Async Encoder</ref> block to compare pre- and post-encoding. Three different FEC encoders are available immediately in this example with the repetition encoder enabled by default. This encoder just repeats every bit 3 times, so it is easy to see the behavior before and after encoding. Simply disable this FEC code and enabling one of the others will change the encoding behavior.</para></listitem><listitem><para>tx_stage3.grc: takes the payload with the CRC32 check and creates the packet structure. Both the header and payload are printed out, where the payload is the input payload+CRC and the header is defined by the &apos;formatter&apos; object. The default formatter just applies an access code (using the default 64-bit digital.packet_utils.default_access_code code) and then it calculates the payload length (in bytes) as a 16-bit value. This 16-bit length field is duplicated, so in the receiver it can check both 16-bit fields to make sure they agree. This formatter also takes a threshold value. The transmitter does not use this threshold. That parameter is used in the receiver to know how many bits can be wrong in the access code and still pass.</para><para>Disabling the <ref refid="classgr_1_1digital_1_1header__format__default" kindref="compound">default header definition</ref> and enabling the other &apos;formatter&apos; to change the protocol. This other protocol definition is the <ref refid="classgr_1_1digital_1_1header__format__counter" kindref="compound">counter header</ref>. It adds the access code and payload length fields as the header like the default formatter. This formatter includes two other fields as well: the number of bits/symbol used in the payload modulator (as a 16-bit field) and a 16-bit counter. Each packet transmitted increments this counter by 1, which means we can keep track of how many packets we have sent and/or received.</para></listitem><listitem><para>tx_stage4.grc: Here we add the modulation to both the header and payload paths, defined by the hdr_const and pld_const objects, respectively. Both are defined as BPSK constellations by default. The output is shown in two <ref refid="page_qtgui" kindref="compound">QTGUI display</ref> graphs. We see the samples in time first, and this is triggering off the TSB tag &quot;packet_len&quot;. When the time display updates, we can see the same pattern right after the tag, which is the header, and then the changing samples are the random values in the payload.</para><para>When we look at this Freq tab of this example, we just see a mostly flat frequency response over the entire frequency range. This response is due to the samples just being +1&apos;s and -1&apos;s with no transition between them and sampled at 1 sampler per symbol. This is not something that we can just transmit as a burst. The square pulses we use provide horrible out-of-band (OOB) emissions if we put this over the air directly, and each burst would go from 0 to +/-1 within the coarse of a single sample, which again provides large OOB emissions. We need to shape the bursts properly from here.</para></listitem><listitem><para>tx_stage5.grc: Adds the Burst Shaper block. The default parameters are to use a Hann window of 50 symbols and to add 10 0&apos;s as pre- and post-padding. We can adjust any of these values to explore what the output burst looks like. We can stop the time sink from updating and turn on the markers for the Re{Data 0} channel to easily count the samples and observe the effect of the window.</para><para>As an aside, the window of 50 produces 25 phasing samples on either side. This is a lot, but we did this to help show off the way the window looks a bit more clearly.</para></listitem><listitem><para>tx_stage6.grc: We then need to up-sample the signal by the number of samples/symbol (sps) and apply our pulse-shaping filter. Again, we are using some larger numbers than we really would in an actual scenario to make it visually clear what is happening. The psf_taps filter creates an RRC filter designed for the 32-arm (set by nfilts) polyphase filterbank resampler. In this RRC Filter Taps object, we set the number of taps to be 15*sps*nfilts. The sps and nfilts are properties of the sample stream and upsampling factor. The value 15 is the number of symbols to represent in this filter; basically that we are going to look over the history effects of 15 samples to manage the inter-symbol interference (ISI). That is a long RRC filter but done so to make the simulation look better. Five or seven is a more realistic value. Similarly, we set sps=4 here to make the time and frequency plots look better. Normally, we would want this closer to 2.</para><para>Now looking at the time domain plot, we see the filtered samples, which are not as pretty as before. They have over- and under-shoots, and if we turned on the line markers, we would not see the original bits easily through this. That is the effect of the RRC filter, which introduces ISI into the transmitted stream. However, when we look at the frequency domain, we see a much better shape, which we can transmit as part of our channel assignment.</para></listitem><listitem><para>tx_stage6a.grc: An aside here to study the RRC filters more. This example adds a second RRC filter (without any resampling) that matches the transmitter&apos;s RRC filter. The matched filter means that the samples are filtered by two RRC filters, which together make a raised cosine (RC) filter. This RC filter is what is known as a Nyquist filter and has the properties of 0 (or very close to 0) ISI. Though we introduced ISI in the transmit RRC filter, the second stage at the receiver undoes that ISI making for a clean, filtered signal. Turning on marker in the time domain shows two clean lines at +1 and -1. The receiver just needs to know which of the sps samples to grad to get the original symbol that was transmitted. But that is the job of the receiver.</para></listitem></itemizedlist>
</para><para>At this point, we have an encoded, modulated, and shaped burst ready to be transmitted out of a radio. The uhd_packet_tx.grc example puts all this together, where we have packaged up most of the transmitter behavior into packet_tx.grc. We then generate random PDU&apos;s, put them through the packet_tx block, and then through a Multiply Const block and into a USRP sink. The Multiply Const block is used for digital scaling of the signal to allow us power control on top of the transmitter gain inside the USRP radio itself.</para></sect2>
</sect1>
<sect1 id="page_packet_comms_1packet_rx">
<title>Understanding the Receiver</title>
<para>The receiver is far more complicated. The work involved here is largely in the detection and synchronization of the received frames. We must assume that frames are coming in as bursts with potentially random time intervals.</para><para>It is important to understand that it is very difficult to make a simple protocol work in all scenarios. We have to assume that some packets will be lost through either a missed detection at the start or poor synchronization statistics during processing of the burst.</para><para>The generic receiver example can be found in packet_rx.grc. This hier block provides the main detection, synchronization, header/payload management, demodulation, and decoding of the PHY frames. The input to this hier block should be not be too far off in frequency. The GNU Radio block <ref refid="classgr_1_1digital_1_1fll__band__edge__cc" kindref="compound">FLL Band-Edge</ref> tends to work well enough, though this is unnecessary if the radio are synchronized in frequency some other way (e.g., with a GPSDO such as is available on USRPs).</para><para>The main flow of samples here is to detect a frame by discovering its known word, which also provides initial estimates on timing and phase offsets of the received frame. We then go through a clock sync block to perform matched filtering and sample time correction to produce resampled symbols at 1 sample/symbol. Now we have samples that are split between the header and payload. We might have information inside of the header that helps the receiver understand the payload. For instance, the length of the payload is generally encoded in the header. So we have to demux the header and payload.</para><para>We assume that we know the length of the header in symbols, which we pass on to the header demodulator chain. Knowing the header modulation, we synchronize the phase and frequency, demodulate the symbols into soft bits, decode those soft bits based on the known header&apos;s FEC code, and then parse the header information. The header parser extracts information about the payload, such as the number of symbols in the payload and possibly the number of bits/symbol used in the payload modulation.</para><para>The <ref refid="classgr_1_1digital_1_1header__payload__demux" kindref="compound">Header/Payload Demux</ref> block sends the appropriate number of samples to the payload demod chain. This chain does its own phase/freq synchronization for the appropriate constellation used in the payload, decodes the samples to soft bits, performs the FEC decoding, and then does the CRC32 check. If this passes, the payload is sent out of the hier block as a PDU with the PHY layer framing stripped.</para><para>When looking at the packet_rx.grc example, notice that we have instrumented a number of debug ports along the way. These ports are designed to make it possible for us to externally hook up graphing and debug blocks in whatever way we are comfortable with to see the signal along the path and more easily debug.</para><sect2 id="page_packet_comms_1packet_rx_correst">
<title>Correlation Estimator</title>
<para>The first stage of the receiver searches for the known word prepended to every burst from the transmitter. The known word has gone through two stages of processing: encoding with the header&apos;s FEC (optional) and modulated by the header&apos;s modulator. The correlation of the known word is done at the input sample stage, so we have to recreate the modulated and possible encoded known word at the receiver.</para><para>To simplify dealing with the encoding process, in packet_rx.grc, we assume one of two types of codes: dummy code (or not coded) and a 3x repetition code. We then just simply calculated the preamble&apos;s bits for both cases. Depending on the header decoder (hdr_dec) used, the hier block knows which preamble to use.</para><para>Next, we need to take the known, encoded word and modulate it with the header&apos;s modulator and pulse shaping filter. We create a simple modulator in the variable &apos;rxmod&apos; that takes the header <ref refid="classgr_1_1digital_1_1constellation" kindref="compound">constellation object</ref> (hdr_const), the number of samples per symbol, and the pulse shape filter&apos;s bandwidth parameter (eb). The <ref refid="namespacegr_1_1digital_1a794029b04429a245eaf4f61ccf5ac47b" kindref="member">Modulate Vector</ref> block than combines this &apos;rxmod&apos; modulator with the &apos;preamble&apos; known word into a vector of complex symbols, here called &apos;modulated_sync_word&apos;. This variable is then passed to the <ref refid="classgr_1_1digital_1_1corr__est__cc" kindref="compound">Correlation Estimator</ref> block.</para><para>One tricky thing about burst communications and network setups is the power of the received samples is unknown and time varying. It is preferential to try to auto-detect the burst and scale the signal to +/-1 before coming in to packet_rx. There is still a lot of work to be done for AGC loops in the hardware and automatic scaling in software. The Correlation Estimator tries to deal with this. We use a threshold as an approximate probability of detection. This value should be set very high; the default here is 99.9%. The correlation tends to scale well as the amplitudes change and for relatively low SNR conditions. Still, it is always possible to miss a detection event or have a false positive.</para><para>Another thing that the Correlation Estimator can do for us is provide information for digital scaling the samples. When received over hardware, the signals tend to be very small, but most of our follow-on processing assumes they are about +/-1. The Correlation Estimator finds the amplitude of the sample where the correlation peak was found, inverts it, and sends it as a tag with the key &apos;amp_est&apos;. We can use this down stream to adjust the amplitude by rescaling the samples from this value. For our packet_rx example, we use the <ref refid="classgr_1_1blocks_1_1multiply__by__tag__value__cc" kindref="compound">Multiply by Tag Value</ref> block, which updates its multiplicitive factor based on the tag. Much of this could be handled by a good AGC routine in the hardware.</para><para>Finally, the main purpose of the Correlation Estimator block is to provide the down-stream synchronization blocks with initial estimates of the timing and phase offset. The peak of the magnitude of the correlation event corresponds to the sampling timing of the data stream.</para><para><verbatim>    1.   /\      2.   _
        /  \         / \
     __/    \__   __/   \__
</verbatim></para><para>The above two drawings show two different correlation scenarios. In scenario 1, the timing is exact and the sample at the peak of that curve is the proper sample time of the last symbol of the known word. In scenario 2, there is a timing offset where the correct timing offset is half-way between two samples. This would be a timing offset of 0.5 (or -0.5). Knowing where that estimated offset is helps our timing recover blocks start near the correct sample offset and then track from there.</para><para>The magnitude of the correlation helps us discover the timing offset. The correlation itself is a complex vector. So where the peak of the magnitude happens, we can look to the complex value of the correlation at the same point and the phase difference between the real and imaginary parts is the phase offset of the signal.</para><para>The Correlation Estimator block calculates the time and phase offsets and creates stream tags for &quot;time_est&quot; and &quot;phase_est&quot;. It also creates two other tags: &quot;corr_start&quot; and &quot;corr_est,&quot; both of which contain the value of the peak of the magnitude of the correlation. Because there is a delay in the correlation algorithm that is affected by the size of the correlation, we need to adjust where the correlation event occurs to where the tags are actually placed on the output stream. The block places the &quot;corr_start&quot; tag on the sample where the correlation actually occurred. It then places the other three tags offset by some &quot;Tag marking delay,&quot; which is a user-calculated value to place the tags at the correct spot in the data stream for the actual start of the known word&apos;s first symbol.</para><para>In packet_rx, we empirically discovered the tag marking delay for different values of the samples/symbol (&apos;sps&apos;) variable and made a list &apos;mark_delays&apos; that is index by &apos;sps&apos; to properly set &apos;mark_delay&apos; for the start of the known word. Getting is correct has a huge effect on the timing recover loop, which can take a while to converge if it starts offset in time by a sample.</para><para>See the example example_corr_est.grc to explore the Correlation Estimator blocks more.</para></sect2>
<sect2 id="page_packet_comms_1packet_rx_timing">
<title>Timing Recovery</title>
<para>After detecting the frame and estimating the time and phase estimates, we have to actually perform the timing synchronization step. The packet_rx example uses the <ref refid="classgr_1_1digital_1_1pfb__clock__sync__ccf" kindref="compound">Polyphase Clock Sync</ref> block to do this. This PFB clock sync (PCS) block typically performs blind timing recovery on a series of samples. It is composed of &apos;nfilt&apos; filters in a filterbank where each filter represents a different phase from [0, 2pi) in steps of 2pi/nfilts. The algorithm finds the correct arm of the filterbank that corresponds to the time shift of the samples. It also knows to look for a &quot;time_est&quot; stream tag and use that information to set its phase arm estimate. If we have a time estimate like scenario 1 above, we have perfect timing and so would select the 0th arm of the filterbank. In scenario 2, we are off by half a sample, so we select arm nfilts/2. The PCS is a tracking loop, so it will start with the initial estimate and then keep track of the timing as well as hone-in on actual timing information of the symbol stream.</para><para>The PCS block uses a filterbank concept to perform its tracking operation. The filters within the filterbank operate best when they are phase offsets of the matched filter. So not only does the block recover the timing, it also performs the matched filtering and produces the optimal 1 sample/symbol output. These are then optimally sampled symbols in the complex constellation space. They need to be mapped back to bits and decoded. But first, we need to parse the header in order to discover information about the payload.</para><para>See the example example_corr_est_and_clock_sync.grc to play with the parameters of time synchronization.</para></sect2>
<sect2 id="page_packet_comms_1packet_rx_hpd">
<title>Header/Payload Demux</title>
<para>Because the header and payload can be modulated differently, the rest of the symbol processing has to be split into two chains. We do this using the <ref refid="classgr_1_1digital_1_1header__payload__demux" kindref="compound">Header/Payload Demux</ref> block (HPD). We assume that we know the protocol, and so the format, coding, and modulation of the header. Generally speaking, these are all controlled through three different objects:</para><para><itemizedlist>
<listitem><para>formatter: An object that described the header structure, derived from <ref refid="classgr_1_1digital_1_1header__format__base" kindref="compound">gr::digital::header_format_base</ref>.</para></listitem><listitem><para>hdr_const: An object that describes the bit and symbol mapping, derived from <ref refid="classgr_1_1digital_1_1constellation" kindref="compound">gr::digital::constellation</ref>.</para></listitem><listitem><para>hdr_dec: An object that describes the FEC code, derived from <ref refid="classgr_1_1fec_1_1generic__decoder" kindref="compound">gr::fec::generic_decoder</ref>.</para></listitem></itemizedlist>
</para><para>Through these, we can ask for any parameter to set up the following stages of processing.</para><para>The HPD block is fairly complicated and we will only use it in one kind of configuration here. See the manual page for the <ref refid="classgr_1_1digital_1_1header__payload__demux" kindref="compound">HPD</ref> block itself for more details. In our use of the HPD block, it receives the data stream and looks for a Trigger Tag Key. We will use &apos;time_est&apos;, one of the tags produced by the Correlation Estimator to indicate the sample that starts the header. When the HPD block sees this trigger key, it passes along a known number of symbols out of the &apos;header&apos; stream port. We know the number of symbols based on the formatter, constellation, and FEC decoder objects. The formatter objects knows the number of bits in the header via the header_nbits() function, the constellation knows how many bits per symbol (via bits_per_symbol()), and the FEC decoder knows the encoding rate (via 1/rate()). The number of symbols in the header is therefore: <verbatim>(header_nbits() * 1/rate()) / bits_per_symbol()
</verbatim></para><para>The HPD then sends this many symbols on to be processed. It holds up any more processing until triggered to do so with information through the &apos;header_data&apos; input message port. The header processing chain will end with the Packet Parser producing the message here.</para><para>When the &apos;header_data&apos; input message port receives valid information, it releases the payload out of the &apos;payload&apos; stream port. The main thing that the &apos;header_data&apos; input message port receives is information about the length of the payload. The HPD parameter &apos;Length tag key&apos; is matched to the message received in &apos;header_data&apos;, which is then used to gate the output of samples as the payload. In our case, we specify the length as the number of symbols through the message key &apos;payload symbols&apos;. This tag then becomes the tagged stream key for the payload chain.</para></sect2>
<sect2 id="page_packet_comms_1packet_rx_hdr_chain">
<title>Header Processing Chain</title>
<para>The header processing chain is kicked off when the HPD block receives the trigger stream tag (i.e., &apos;time_est&apos;). We must first correct the phase and fine frequency offset of the received samples. The Correlation Estimator block will help us with this through the &apos;phase_est&apos; tag. The <ref refid="classgr_1_1digital_1_1costas__loop__cc" kindref="compound">Costas Loop</ref> looks for this tag, and, when found, it will take this estimate and reset its own internal phase value, which greatly speed up acquisition. The Costas loop will then track the phase and frequency over the course of the header.</para><para>With the constellation locked in time, phase, and frequency, we can not decode the complex symbols. We use a <ref refid="classgr_1_1digital_1_1constellation__soft__decoder__cf" kindref="compound">Constellation Soft Decoder</ref> block for this, which uses the &apos;hdr_const&apos; object to know the mappings from complex space to bits. Specifically, it performs a soft decoding, so the outputs are soft decision bits, which is useful for FEC decoding that is performed next.</para><para>The <ref refid="classgr_1_1fec_1_1decoder" kindref="compound">FEC decoder</ref> operates on the soft decisions based on the hdr_dec object. Because of the bounded nature of the header, we would expect simple block codes used here as well as a fairly robust and easy to process code. In the current examples, we only provide no code (via the <ref refid="classgr_1_1fec_1_1code_1_1dummy__encoder" kindref="compound">Dummy Encoder</ref> / <ref refid="classgr_1_1fec_1_1code_1_1dummy__decoder" kindref="compound">Dummy Decoder</ref> classes) or a repetition code (via the <ref refid="classgr_1_1fec_1_1code_1_1repetition__encoder" kindref="compound">Repetition Encoder</ref> / <ref refid="classgr_1_1fec_1_1code_1_1repetition__decoder" kindref="compound">Repetition Decoder</ref> classes). The output of the FEC decoder block is a bit stream where each item is either a 1 or a 0.</para><para>The last step in the header processing stage is to parse that bit stream back into the header. The <ref refid="classgr_1_1digital_1_1protocol__parser__b" kindref="compound">Packet Parser</ref> block does this by receiving a bit stream, passing it to the <ref refid="classgr_1_1digital_1_1header__format__base_1af1eecb5bc63e1186a08f001db78a39ba" kindref="member">parse</ref> function of the packet formatter object, and emitting a message with the information about the parsed data.</para><para>The packet parsing is explained in detail in the <ref refid="classgr_1_1digital_1_1header__format__base" kindref="compound">Packet Formatter Base</ref> class. The parse function packs together the received bits into the different header fields, checks that the header is correct, and the constructs a PMT dictionary of the header information, such as the payload length and other possible information like the type of constellation or FEC coding used on the payload bits. This is the message that gets passed back to the HPD block to guide the payload processing.</para><para>If the packet formatter parsing operation fails by not getting enough data or if the data is corrupted, it will return false. When the Packet Parser sees this, it emits a message that just contains a <ref refid="page_pmt" kindref="compound">PMT</ref> False (pmt::PMT_F), which resets the HPD block to start looking for another header trigger event.</para><para>If the header parsing completes successfully, the HPD block gets a message with information about the payload. Most importantly, it gets information about how many symbols make up the payload. It then sends a tagged stream to the payload processing chain with this many symbols.</para></sect2>
<sect2 id="page_packet_comms_1packet_rx_pld_chain">
<title>Payload Processing Chain</title>
<para>The payload processing chain behaves very similarly to the header processing chain for the first few blocks. It starts by locking the phase and frequency in another <ref refid="classgr_1_1digital_1_1costas__loop__cc" kindref="compound">Costas loop</ref>, and then perform <ref refid="classgr_1_1digital_1_1constellation__soft__decoder__cf" kindref="compound">soft decoding</ref> on the symbols using the &apos;pld_const&apos; object. Because we come in as symbols and out as soft decisions, the constellation soft decoder will produce <ref refid="classgr_1_1digital_1_1constellation_1ae5322f145b0af1fb23010aa3da589e9f" kindref="member">bits_per_symbol()</ref> times as many outputs as inputs, but the soft decoder will not change the tag stream information. To compensate for this, we use a <ref refid="classgr_1_1blocks_1_1tagged__stream__multiply__length" kindref="compound">Tagged Stream Multiply Length</ref> block to update the tagged stream tag &quot;payload symbols&quot;. We then move from the tagged stream mode into PDU mode and perform the FEC decoding through the <ref refid="classgr_1_1fec_1_1async__decoder" kindref="compound">asynchronous FEC decoder</ref>. This decoder is nice in that it comes in with soft bits and produces packed bytes. These packed bytes are now the full payload with the CRC32 appended. The <ref refid="classgr_1_1digital_1_1crc32__async__bb" kindref="compound">Async CRC32</ref> block in &quot;Check CRC&quot; mode will take this PDU of packed bytes, calculate the CRC and check it against the final four bytes of the payload. If they match, the PDU is stripped of the CRC bytes and the frame is passed out of the hier block. This PDU frame is now ready for use in higher layers of processing.</para><para>This takes us through the entire processing chain on the receiver. From here, it is a matter of tweaking parameters and playing with options and other setups to improve behavior. </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
